import java.util.Random;
// import static java.lang.Math.*;

public class Vaidya_Rujuta_pa3_floyd {
    //Declarations for global access
    public static int n = new Random().nextInt(6) + 5; // randomly select n between 5 and 10
    public static int[][] A = new int[n][n]; // adjacency matrix
    public static int[][] P = new int[n][n]; // shortest path matrix
    public static int[][] D = new int[n][n]; //final adjacency matrix
    public static void main(String[] args) {

        //Size of random matrix
        System.out.println("n = " + n);


        // Initialize P to 0
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                P[i][j] = 0;

            }
        }

        // create adjacency matrix A with random numbers from 1 to 10
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    A[i][j] = 0; //diagonals should be 0
                } else {
                    A[i][j] = new Random().nextInt(10) + 1; //Assign values randomly
                    A[j][i] = A[i][j]; // As per given condition
                }
            }
        }

        // print adjacency matrix - intial randomly generated matrix
        System.out.println("A matrix: initial randomly generated matrix before floyd algorithm");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (A[i][j] > 9) {
                    System.out.print(" " + A[i][j] + " ");
                } else {
                    System.out.print(" " + A[i][j] + "  ");
                }
            }
            System.out.println();
        }

        // Initializing new matrix D which is to be updated
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
            D[i][j] = A[i][j];
        }
    }

        //Floyd's Algorithm to update D matrix and generate P matrix
  for(int k = 0; k < n ; k++){
      for(int i = 0; i < n; i ++){
          for(int j = 0; j< n; j++){
              if (D[i][j] > D[i][k] + D[k][j]) {
                  D[i][j] = D[i][k] + D[k][j];
                  P[i][j] = k+1; // update P matrix
              }
          }
      }
  }

//        System.out.println("D matrix: Updated matrix generated by floyd to calculate Vi");
//        for (int i = 0; i < n; i++) {
//            for (int j = 0; j < n; j++) {
//                if (D[i][j] > 9) {
//                    System.out.print(" " + D[i][j] + " ");
//                } else {
//                    System.out.print(" " + D[i][j] + "  ");
//                }
//            }
//            System.out.println();
//        }


        // print shortest path matrix P
        System.out.println("P matrix:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (P[i][j] > 9) {
                    System.out.print(" " + P[i][j] + " ");
                } else {
                    System.out.print(" " + P[i][j] + "  ");
                }
            }
            System.out.println();
        }


        for(int i = 0; i< n; i++){
            System.out.println("V" + (i+1) + "-Vj: Shortest path and length");
            for(int j = 0; j < n; j++){
                // print ith value for path
                System.out.print("V"+(i+1) +" ");
                printPath(i,j);
                //print route and path
                System.out.print("V" + (j+1) + ": " +D[i][j]);
                System.out.println(" ");
            }
        }
    }

    //Recursively print shortest path using final matrix D
    private static int printPath(int i, int j) {
                if (P[i][j] != 0){
                    printPath(i, P[i][j] - 1);
                    System.out.print("V"+P[i][j] + " ");
                    printPath(P[i][j] - 1, j);
                    return 0;
                }else{
                    return 0;
                }

            }
        }





